__text_start:
__start:
    0025 E5CF      LDI	R28,0x5F
    0026 E0D2      LDI	R29,2
    0027 BFCD      OUT	0x3D,R28
    0028 BFDE      OUT	0x3E,R29
    0029 51C0      SUBI	R28,0x10
    002A 40D0      SBCI	R29,0
    002B EA0A      LDI	R16,0xAA
    002C 8308      STD	Y+0,R16
    002D 2400      CLR	R0
    002E E6E0      LDI	R30,0x60
    002F E0F0      LDI	R31,0
    0030 E010      LDI	R17,0
    0031 3BE3      CPI	R30,0xB3
    0032 07F1      CPC	R31,R17
    0033 F011      BEQ	0x0036
    0034 9201      ST	R0,Z+
    0035 CFFB      RJMP	0x0031
    0036 8300      STD	Z+0,R16
    0037 E4EA      LDI	R30,0x4A
    0038 E0F0      LDI	R31,0
    0039 E6A0      LDI	R26,0x60
    003A E0B0      LDI	R27,0
    003B E010      LDI	R17,0
    003C 34EA      CPI	R30,0x4A
    003D 07F1      CPC	R31,R17
    003E F021      BEQ	0x0043
    003F 95C8      LPM
    0040 9631      ADIW	R30,1
    0041 920D      ST	R0,X+
    0042 CFF9      RJMP	0x003C
    0043 D19E      RCALL	_main
_exit:
    0044 CFFF      RJMP	_exit
_InitUart:
  i                    --> R20
  baud                 --> R16
    0045 D366      RCALL	push_gset1
FILE: C:\projects\SynthMod\100-1001\firmware\midi.c
(0001) /*******************************************************************************
(0002) 	Midi.c
(0003) 
(0004) 	These are the functions that provide the interface to the midi port
(0005) 
(0006) *******************************************************************************/
(0007) 
(0008) #include <io8515v.h>
(0009) #include <macros.h>
(0010) #include "smb.h"
(0011) #include "midi.h"
(0012) 
(0013) #pragma interrupt_handler iTxd:11 
(0014) #pragma interrupt_handler iRxd:iv_UART_RX
(0015) #pragma interrupt_handler iTimer:iv_TIMER0_OVF
(0016) 
(0017) char GateShadow;
(0018) 
(0019) typedef struct {
(0020) 	volatile int head;
(0021) 	volatile int tail;
(0022) 	volatile int nchar;
(0023) 	volatile int size;
(0024) }IODESC;
(0025) 
(0026) volatile IODESC txdesc;
(0027) char txbuff[32];
(0028) volatile IODESC rxdesc;
(0029) char rxbuff[32];
(0030) 
(0031) void InitUart(int baud)
(0032) {
(0033) 	int i;
(0034) 
(0035) 	UCR |= 0x18;	/*	enable uart rec and xmit	*/
    0046 B18A      IN	R24,0x0A
    0047 6188      ORI	R24,0x18
    0048 B98A      OUT	0x0A,R24
(0036) 	UBRR = baud;
    0049 B909      OUT	0x09,R16
(0037) 	txdesc.head = 0;	/*	initialize transmit descriptor	*/
    004A 2422      CLR	R2
    004B 2433      CLR	R3
    004C 923000AB  STS	_txdesc+1,R3
    004E 922000AA  STS	_txdesc,R2
(0038) 	txdesc.tail = 0;
    0050 923000AD  STS	_txdesc+3,R3
    0052 922000AC  STS	_txdesc+2,R2
(0039) 	txdesc.nchar = 0;
    0054 923000AF  STS	0xAF,R3
    0056 922000AE  STS	0xAE,R2
(0040) 	txdesc.size = 32;
    0058 E280      LDI	R24,0x20
    0059 E090      LDI	R25,0
    005A 939000B1  STS	0xB1,R25
    005C 938000B0  STS	0xB0,R24
(0041) 	rxdesc.head = 0;	/*	initialize receiever descriptor	*/
    005E 92300083  STS	_rxdesc+1,R3
    0060 92200082  STS	_rxdesc,R2
(0042) 	rxdesc.tail = 0;
    0062 92300085  STS	_rxdesc+3,R3
    0064 92200084  STS	_rxdesc+2,R2
(0043) 	rxdesc.size = 32;
    0066 93900089  STS	0x89,R25
    0068 93800088  STS	0x88,R24
(0044) 	rxdesc.nchar = 0;
    006A 92300087  STS	0x87,R3
    006C 92200086  STS	0x86,R2
(0045) 	for(i=0;i<32;++i)
    006E 2744      CLR	R20
    006F 2755      CLR	R21
(0046) 	{
(0047) 		txbuff[i] = 'o';
    0070 E88A      LDI	R24,0x8A
    0071 E090      LDI	R25,0
    0072 2FE4      MOV	R30,R20
    0073 2FF5      MOV	R31,R21
    0074 0FE8      ADD	R30,R24
    0075 1FF9      ADC	R31,R25
    0076 E68F      LDI	R24,0x6F
    0077 8380      STD	Z+0,R24
(0048) 		rxbuff[i] = 'i';
    0078 E682      LDI	R24,0x62
    0079 E090      LDI	R25,0
    007A 2FE4      MOV	R30,R20
    007B 2FF5      MOV	R31,R21
    007C 0FE8      ADD	R30,R24
    007D 1FF9      ADC	R31,R25
    007E E689      LDI	R24,0x69
    007F 8380      STD	Z+0,R24
    0080 5F4F      SUBI	R20,0xFF
    0081 4F5F      SBCI	R21,0xFF
    0082 3240      CPI	R20,0x20
    0083 E0E0      LDI	R30,0
    0084 075E      CPC	R21,R30
    0085 F354      BLT	0x0070
(0049) 	}
(0050) }
    0086 D328      RCALL	pop_gset1
    0087 9508      RET
(0051) 
(0052) void Disable(void)		/*	disable interrupts	*/
(0053) {
(0054) 	SREG &= ~0x80;
_Disable:
    0088 94F8      BCLR	7
(0055) }
    0089 9508      RET
(0056) 
(0057) void Enable(void)		/* enable interrupts	*/
(0058) {
(0059) 	SREG |= 0x80;		
_Enable:
    008A 9478      BSET	7
(0060) }
    008B 9508      RET
(0061) 
(0062) void EnableRxIRQ(void)	
(0063) {
(0064) 	/**************************
(0065) 	** Enable Receiver interrupts
(0066) 	**************************/
(0067) 	UCR |= 0x80;
_EnableRxIRQ:
    008C 9A57      SBI	0x0A,7
(0068) }
    008D 9508      RET
(0069) 
(0070) void DisableRxIRQ(void)
(0071) {
(0072) 	/**************************
(0073) 	** Disable Receirver interrupts
(0074) 	**************************/
(0075) 	UCR &= ~0x80;
_DisableRxIRQ:
    008E 9857      CBI	0x0A,7
(0076) }
    008F 9508      RET
(0077) 
(0078) void EnableTxIRQ(void)
(0079) {
(0080) 	UCR |= 0x20;	/*	enable transmit data register empty interrupt	*/
_EnableTxIRQ:
    0090 9A55      SBI	0x0A,5
(0081) }
    0091 9508      RET
(0082) 
(0083) void DisableTxIRQ(void)
(0084) {
(0085) 	UCR &= ~0x20;	/*	disable transmit data register empty interrupt	*/
_DisableTxIRQ:
    0092 9855      CBI	0x0A,5
(0086) }
    0093 9508      RET
_iRxd:
  c                    --> R16
    0094 922A      ST	R2,-Y
    0095 923A      ST	R3,-Y
    0096 924A      ST	R4,-Y
    0097 925A      ST	R5,-Y
    0098 930A      ST	R16,-Y
    0099 938A      ST	R24,-Y
    009A 939A      ST	R25,-Y
    009B 93EA      ST	R30,-Y
    009C 93FA      ST	R31,-Y
    009D B62F      IN	R2,0x3F
    009E 922A      ST	R2,-Y
(0087) 
(0088) void iRxd(void)
(0089) {
(0090) 	/**************************
(0091) 	** Interrupt handler for 
(0092) 	** Receive Interrupts
(0093) 	**************************/
(0094) 	char c = UDR;	/*	read data from receive data reg	*/
    009F B10C      IN	R16,0x0C
(0095) 	if(rxdesc.nchar < rxdesc.size)	/*	is there space to put char?	*/
    00A0 90200088  LDS	R2,0x88
    00A2 90300089  LDS	R3,0x89
    00A4 90400086  LDS	R4,0x86
    00A6 90500087  LDS	R5,0x87
    00A8 1442      CP	R4,R2
    00A9 0453      CPC	R5,R3
    00AA F564      BGE	0x00D7
(0096) 	{
(0097) 		rxbuff[rxdesc.head++] = c;	/*	put character into buffer	*/
    00AB 90200082  LDS	R2,_rxdesc
    00AD 90300083  LDS	R3,_rxdesc+1
    00AF 2D82      MOV	R24,R2
    00B0 2D93      MOV	R25,R3
    00B1 9601      ADIW	R24,1
    00B2 93900083  STS	_rxdesc+1,R25
    00B4 93800082  STS	_rxdesc,R24
    00B6 E682      LDI	R24,0x62
    00B7 E090      LDI	R25,0
    00B8 2DE2      MOV	R30,R2
    00B9 2DF3      MOV	R31,R3
    00BA 0FE8      ADD	R30,R24
    00BB 1FF9      ADC	R31,R25
    00BC 8300      STD	Z+0,R16
(0098) 		if(rxdesc.head == rxdesc.size) rxdesc.head = 0;	/*	wrap head pointer	*/
    00BD 90200088  LDS	R2,0x88
    00BF 90300089  LDS	R3,0x89
    00C1 90400082  LDS	R4,_rxdesc
    00C3 90500083  LDS	R5,_rxdesc+1
    00C5 1442      CP	R4,R2
    00C6 0453      CPC	R5,R3
    00C7 F431      BNE	0x00CE
    00C8 2422      CLR	R2
    00C9 2433      CLR	R3
    00CA 92300083  STS	_rxdesc+1,R3
    00CC 92200082  STS	_rxdesc,R2
(0099) 		rxdesc.nchar++;	/*	increment character count	*/
    00CE 91800086  LDS	R24,0x86
    00D0 91900087  LDS	R25,0x87
    00D2 9601      ADIW	R24,1
    00D3 93900087  STS	0x87,R25
    00D5 93800086  STS	0x86,R24
(0100) 	}	/*	otherwise, just drop character	*/
(0101) }
    00D7 9029      LD	R2,Y+
    00D8 BE2F      OUT	0x3F,R2
    00D9 91F9      LD	R31,Y+
    00DA 91E9      LD	R30,Y+
    00DB 9199      LD	R25,Y+
    00DC 9189      LD	R24,Y+
    00DD 9109      LD	R16,Y+
    00DE 9059      LD	R5,Y+
    00DF 9049      LD	R4,Y+
    00E0 9039      LD	R3,Y+
    00E1 9029      LD	R2,Y+
    00E2 9518      RETI
_iTxd:
  c                    --> R20
    00E3 D2F0      RCALL	push_lset
    00E4 D2C7      RCALL	push_gset1
(0102) 
(0103) void iTxd(void)		/* interrupt handler for uart	*/
(0104) {
(0105) 	char c;
(0106) 
(0107) 	c = (char)txbuff[txdesc.tail++];		/*	get character from buffer	*/
    00E5 902000AC  LDS	R2,_txdesc+2
    00E7 903000AD  LDS	R3,_txdesc+3
    00E9 2D82      MOV	R24,R2
    00EA 2D93      MOV	R25,R3
    00EB 9601      ADIW	R24,1
    00EC 939000AD  STS	_txdesc+3,R25
    00EE 938000AC  STS	_txdesc+2,R24
    00F0 E88A      LDI	R24,0x8A
    00F1 E090      LDI	R25,0
    00F2 2DE2      MOV	R30,R2
    00F3 2DF3      MOV	R31,R3
    00F4 0FE8      ADD	R30,R24
    00F5 1FF9      ADC	R31,R25
    00F6 8140      LDD	R20,Z+0
(0108) 	--txdesc.nchar;						/*	one less character to send	*/
    00F7 918000AE  LDS	R24,0xAE
    00F9 919000AF  LDS	R25,0xAF
    00FB 9701      SBIW	R24,1
    00FC 939000AF  STS	0xAF,R25
    00FE 938000AE  STS	0xAE,R24
(0109) 	if(txdesc.nchar == 0)				/*	is xmit buffer empty?	*/				
    0100 902000AE  LDS	R2,0xAE
    0102 903000AF  LDS	R3,0xAF
    0104 2022      TST	R2
    0105 F419      BNE	0x0109
    0106 2033      TST	R3
    0107 F409      BNE	0x0109
(0110) 		DisableTxIRQ();					/*	stop transmitting data	*/
    0108 DF89      RCALL	_DisableTxIRQ
(0111) 	if(txdesc.tail == txdesc.size) txdesc.tail = 0;	/* wrap tail pointer	*/
    0109 902000B0  LDS	R2,0xB0
    010B 903000B1  LDS	R3,0xB1
    010D 904000AC  LDS	R4,_txdesc+2
    010F 905000AD  LDS	R5,_txdesc+3
    0111 1442      CP	R4,R2
    0112 0453      CPC	R5,R3
    0113 F431      BNE	0x011A
    0114 2422      CLR	R2
    0115 2433      CLR	R3
    0116 923000AD  STS	_txdesc+3,R3
    0118 922000AC  STS	_txdesc+2,R2
(0112) 	UDR = c;
    011A B94C      OUT	0x0C,R20
(0113) }
    011B D293      RCALL	pop_gset1
    011C D2CE      RCALL	pop_lset
    011D 9518      RETI
_GetC:
  c                    --> R20
    011E D28D      RCALL	push_gset1
(0114) 
(0115) int GetC(void)
(0116) {
(0117) 	/*********************************
(0118) 	** Get a character from the UART
(0119) 	** If there is no character, wait
(0120) 	*********************************/
(0121) 	int c;
(0122) 
(0123) 	while(rxdesc.nchar == 0);	/*	wait for character to apear in buffer	*/
    011F 90200086  LDS	R2,0x86
    0121 90300087  LDS	R3,0x87
    0123 2022      TST	R2
    0124 F411      BNE	0x0127
    0125 2033      TST	R3
    0126 F3C1      BEQ	0x011F
(0124) 	Disable();			/*	disable interrupts	*/
    0127 DF60      RCALL	_Disable
(0125) 	c = (int)rxbuff[rxdesc.tail++];		/*	get character from buffer	*/
    0128 90200084  LDS	R2,_rxdesc+2
    012A 90300085  LDS	R3,_rxdesc+3
    012C 2D82      MOV	R24,R2
    012D 2D93      MOV	R25,R3
    012E 9601      ADIW	R24,1
    012F 93900085  STS	_rxdesc+3,R25
    0131 93800084  STS	_rxdesc+2,R24
    0133 E682      LDI	R24,0x62
    0134 E090      LDI	R25,0
    0135 2DE2      MOV	R30,R2
    0136 2DF3      MOV	R31,R3
    0137 0FE8      ADD	R30,R24
    0138 1FF9      ADC	R31,R25
    0139 8140      LDD	R20,Z+0
    013A 2755      CLR	R21
(0126) 	if(rxdesc.tail == rxdesc.size) rxdesc.tail = 0;	/*	wrap tail pointer	*/
    013B 90200088  LDS	R2,0x88
    013D 90300089  LDS	R3,0x89
    013F 90400084  LDS	R4,_rxdesc+2
    0141 90500085  LDS	R5,_rxdesc+3
    0143 1442      CP	R4,R2
    0144 0453      CPC	R5,R3
    0145 F431      BNE	0x014C
    0146 2422      CLR	R2
    0147 2433      CLR	R3
    0148 92300085  STS	_rxdesc+3,R3
    014A 92200084  STS	_rxdesc+2,R2
(0127) 	rxdesc.nchar--;	/*	decrement number of chars in buffer	*/
    014C 91800086  LDS	R24,0x86
    014E 91900087  LDS	R25,0x87
    0150 9701      SBIW	R24,1
    0151 93900087  STS	0x87,R25
    0153 93800086  STS	0x86,R24
(0128) 	Enable();
    0155 DF34      RCALL	_Enable
(0129) 	return c;	/*	return fetched character	*/	
    0156 2F04      MOV	R16,R20
    0157 2F15      MOV	R17,R21
    0158 D256      RCALL	pop_gset1
    0159 9508      RET
_PutC:
  i                    --> R20
    015A D251      RCALL	push_gset1
    015B 2F40      MOV	R20,R16
    015C 2F51      MOV	R21,R17
(0130) }
(0131) 
(0132) void PutC(int i)
(0133) {
(0134) 	while(txdesc.nchar == txdesc.size);	/*	pend on buffer full	*/
    015D 902000B0  LDS	R2,0xB0
    015F 903000B1  LDS	R3,0xB1
    0161 904000AE  LDS	R4,0xAE
    0163 905000AF  LDS	R5,0xAF
    0165 1442      CP	R4,R2
    0166 0453      CPC	R5,R3
    0167 F3A9      BEQ	0x015D
(0135) 	Disable();	/*	Disable interrupts	*/
    0168 DF1F      RCALL	_Disable
(0136) 	txbuff[txdesc.head++] = (char)i;	/*	put data into buffer	*/
    0169 902000AA  LDS	R2,_txdesc
    016B 903000AB  LDS	R3,_txdesc+1
    016D 2D82      MOV	R24,R2
    016E 2D93      MOV	R25,R3
    016F 9601      ADIW	R24,1
    0170 939000AB  STS	_txdesc+1,R25
    0172 938000AA  STS	_txdesc,R24
    0174 E88A      LDI	R24,0x8A
    0175 E090      LDI	R25,0
    0176 2DE2      MOV	R30,R2
    0177 2DF3      MOV	R31,R3
    0178 0FE8      ADD	R30,R24
    0179 1FF9      ADC	R31,R25
    017A 8340      STD	Z+0,R20
(0137) 	if(txdesc.head == txdesc.size) txdesc.head = 0;	/*	wrap head pointer	*/
    017B 902000B0  LDS	R2,0xB0
    017D 903000B1  LDS	R3,0xB1
    017F 904000AA  LDS	R4,_txdesc
    0181 905000AB  LDS	R5,_txdesc+1
    0183 1442      CP	R4,R2
    0184 0453      CPC	R5,R3
    0185 F431      BNE	0x018C
    0186 2422      CLR	R2
    0187 2433      CLR	R3
    0188 923000AB  STS	_txdesc+1,R3
    018A 922000AA  STS	_txdesc,R2
(0138) 	if(txdesc.nchar == 0)	/*	first char in buff?	*/
    018C 902000AE  LDS	R2,0xAE
    018E 903000AF  LDS	R3,0xAF
    0190 2022      TST	R2
    0191 F419      BNE	0x0195
    0192 2033      TST	R3
    0193 F409      BNE	0x0195
(0139) 		EnableTxIRQ();		/*	start transmit interrupt	*/
    0194 DEFB      RCALL	_EnableTxIRQ
(0140) 	txdesc.nchar++;
    0195 918000AE  LDS	R24,0xAE
    0197 919000AF  LDS	R25,0xAF
    0199 9601      ADIW	R24,1
    019A 939000AF  STS	0xAF,R25
    019C 938000AE  STS	0xAE,R24
(0141) 	Enable();	/*	enable interrupts	*/	
    019E DEEB      RCALL	_Enable
(0142) }
    019F D20F      RCALL	pop_gset1
    01A0 9508      RET
_iTimer:
    01A1 922A      ST	R2,-Y
    01A2 938A      ST	R24,-Y
    01A3 B62F      IN	R2,0x3F
    01A4 922A      ST	R2,-Y
(0143) 
(0144) //--------------------------------------------------------------------------
(0145) // Timer STuff...
(0146) //--------------------------------------------------------------------------
(0147) 
(0148) unsigned char Counter;
(0149) unsigned char CRV;
(0150) 
(0151) void iTimer(void)
(0152) {
(0153) 	//-----------------------------------
(0154) 	//timer interrupt handler
(0155) 	//-----------------------------------
(0156) 	TCNT0 = ~31;
    01A5 EE80      LDI	R24,0xE0
    01A6 BF82      OUT	0x32,R24
(0157) 	if(--Counter == 0)
    01A7 91800061  LDS	R24,_Counter
    01A9 5081      SUBI	R24,1
    01AA 2E28      MOV	R2,R24
    01AB 92200061  STS	_Counter,R2
    01AD 2388      TST	R24
    01AE F489      BNE	0x01C0
(0158) 	{
(0159) 		GateShadow ^= 0x02;
    01AF E082      LDI	R24,2
    01B0 902000B2  LDS	R2,_GateShadow
    01B2 2628      EOR	R2,R24
    01B3 922000B2  STS	_GateShadow,R2
(0160) 		LED_PORT = ~GateShadow;
    01B5 9420      COM	R2
    01B6 9220C400  STS	0xC400,R2
(0161) 		GATE_PORT = GateShadow;
    01B8 902000B2  LDS	R2,_GateShadow
    01BA 9220C000  STS	0xC000,R2
(0162) 		Counter = CRV;
    01BC 90200060  LDS	R2,_CRV
    01BE 92200061  STS	_Counter,R2
(0163) 	}
(0164) }
    01C0 9029      LD	R2,Y+
    01C1 BE2F      OUT	0x3F,R2
    01C2 9189      LD	R24,Y+
    01C3 9029      LD	R2,Y+
    01C4 9518      RETI
(0165) 
(0166) void EnableTimerIrq(void)
(0167) {
(0168) 	TIMSK |= 0x02;	//enable timer interrupt
_EnableTimerIrq:
    01C5 B789      IN	R24,0x39
    01C6 6082      ORI	R24,2
    01C7 BF89      OUT	0x39,R24
(0169) }
    01C8 9508      RET
(0170) 
(0171) void DisableTimerIrq(void)
(0172) {
(0173) 	TIMSK &= ~0x02;	//disable timer interrupt
_DisableTimerIrq:
    01C9 B789      IN	R24,0x39
    01CA 7F8D      ANDI	R24,0xFD
    01CB BF89      OUT	0x39,R24
(0174) }
    01CC 9508      RET
(0175) 
(0176) void InitTimer(void)
(0177) {
(0178) 	TCCR0 = 5;	//system clock divided by 1024
_InitTimer:
    01CD E085      LDI	R24,5
    01CE BF83      OUT	0x33,R24
(0179) 	TCNT0 = ~31;
    01CF EE80      LDI	R24,0xE0
    01D0 BF82      OUT	0x32,R24
(0180) 	Counter = 31;
    01D1 E18F      LDI	R24,0x1F
    01D2 93800061  STS	_Counter,R24
(0181) 	CRV = 31;
    01D4 93800060  STS	_CRV,R24
(0182) }
    01D6 9508      RET
(0183) 
(0184) 
(0185) void Delay()
(0186) {
(0187) 	unsigned char a, b;
(0188) 
(0189) 	for (a = 1; a; a++)
_Delay:
  a                    --> R16
  b                    --> R18
    01D7 E001      LDI	R16,1
    01D8 C006      RJMP	0x01DF
(0190) 		for (b = 1; b; b++);
    01D9 E021      LDI	R18,1
    01DA C001      RJMP	0x01DC
    01DB 9523      INC	R18
    01DC 2322      TST	R18
    01DD F7E9      BNE	0x01DB
    01DE 9503      INC	R16
    01DF 2300      TST	R16
    01E0 F7C1      BNE	0x01D9
(0191) }
    01E1 9508      RET
_main:
  currentnote          --> R12
  v                    --> R14
  nextnote             --> Y+12
  chan                 --> Y+11
  state                --> Y+10
  cmd                  --> Y+9
  c                    --> Y+8
    01E2 972E      SBIW	R28,0xE
(0192) 
(0193) enum {IDLE,NOTE0,NOTE1};
(0194) 
(0195) #define SYSEX			0xf0
(0196) #define SYSCOMUNDEF		0xf1
(0197) #define SYSCOMSONGPOS	0xf2
(0198) #define SYSCOMSONGSEL	0xf3
(0199) #define SYSCOMUNDEF1	0xf4
(0200) #define SYSCOMUNDEF2	0xf5
(0201) #define SYSCOMTUNEREQ	0xf6
(0202) #define SYSEXEND		0xf7
(0203) #define SYSRTCLOCK		0xf8
(0204) #define SYSRTUNDEF		0xf9
(0205) #define SYSRTSTART		0xfa
(0206) #define SYSRTCONTINUE	0xfb
(0207) #define SYSRTSTOP		0xfc
(0208) #define SYSRTUNDEF1		0xfd
(0209) #define SYSRTACTIVESEN	0xfe
(0210) #define SYSRTRESET		0xff
(0211) 
(0212) #define NOTEON	0x90
(0213) #define NOTEOFF	0x80
(0214) #define NOTEPRES	0xa0		//note pressure
(0215) #define CHANPRES	0xb0		//channel pressure
(0216) #define CONTROL	0xd0			//control change
(0217) #define WHEEL	0xe0			//pitch wheel change
(0218) #define PATCH	0xc0			//patch change
(0219) 
(0220) 
(0221) #define MIDI_CLOCK	0x80
(0222) #define MIDI_START	0x40
(0223) #define MIDI_RESET	0x20
(0224) #define MIDI_GATE	0x01
(0225) 
(0226) main()
(0227) {
(0228) 	int currentnote,nextnote;
(0229) 	char c;
(0230) 	char cmd;
(0231) 	char chan;
(0232) 	char state;
(0233) 	int v;
(0234) 
(0235) 	InitSPI();		/*	initialize the SPI port	*/
    01E3 D193      RCALL	_InitSPI
(0236) 	InitTimer();	//initialize real clock timer
    01E4 DFE8      RCALL	_InitTimer
(0237) 	InitUart(BAUD_MIDI);
    01E5 E00F      LDI	R16,0xF
    01E6 E010      LDI	R17,0
    01E7 DE5D      RCALL	_InitUart
(0238) 	EnableRxIRQ();	/*	enable receive interrupt	*/
    01E8 DEA3      RCALL	_EnableRxIRQ
(0239) 	EnableTimerIrq();
    01E9 DFDB      RCALL	_EnableTimerIrq
(0240) 	GateShadow = 0;
    01EA 2422      CLR	R2
    01EB 922000B2  STS	_GateShadow,R2
(0241) 	GATE_PORT = GateShadow;	/*	set all outputs to zero	*/
    01ED 9220C000  STS	0xC000,R2
(0242) 	LED_PORT = ~GateShadow;
    01EF 9420      COM	R2
    01F0 9220C400  STS	0xC400,R2
(0243) 	Enable();		/*	enable global interrupts	*/
    01F2 DE97      RCALL	_Enable
    01F3 C17E      RJMP	0x0372
(0244) 	
(0245) 	while(1)
(0246) 	{
(0247) 		c = GetC();
    01F4 DF29      RCALL	_GetC
    01F5 8708      STD	Y+8,R16
(0248) 		if(c & 0x080)	//is it a command?
    01F6 2E00      MOV	R0,R16
    01F7 FF07      SBRS	R16,7
    01F8 C071      RJMP	0x026A
(0249) 		{
(0250) 			if(c < 0x0f0)
    01F9 2D80      MOV	R24,R0
    01FA 3F00      CPI	R16,0xF0
    01FB F488      BCC	0x020D
(0251) 			{
(0252) 				//process this stuff, dispose of everything else
(0253) 				cmd = (char)(c & 0xf0);
    01FC 2799      CLR	R25
    01FD 7F80      ANDI	R24,0xF0
    01FE 7090      ANDI	R25,0
    01FF 8789      STD	Y+9,R24
(0254) 				chan = (char)(c & 0x0f);
    0200 8588      LDD	R24,Y+8
    0201 2799      CLR	R25
    0202 708F      ANDI	R24,0xF
    0203 7090      ANDI	R25,0
    0204 878B      STD	Y+11,R24
(0255) 				if(cmd == NOTEON)
    0205 8589      LDD	R24,Y+9
    0206 3980      CPI	R24,0x90
    0207 F009      BEQ	0x0209
    0208 C169      RJMP	0x0372
(0256) 					state = NOTE0;
    0209 2400      CLR	R0
    020A 9403      INC	R0
    020B 860A      STD	Y+10,R0
(0257) 			}
    020C C165      RJMP	0x0372
(0258) 			else
(0259) 			{
(0260) 				switch(c)
    020D 84A8      LDD	R10,Y+8
    020E 24BB      CLR	R11
    020F 2D8A      MOV	R24,R10
    0210 2D9B      MOV	R25,R11
    0211 3F80      CPI	R24,0xF0
    0212 E0E0      LDI	R30,0
    0213 079E      CPC	R25,R30
    0214 F40C      BGE	0x0216
    0215 C15C      RJMP	0x0372
    0216 EF8F      LDI	R24,0xFF
    0217 158A      CP	R24,R10
    0218 059B      CPC	R25,R11
    0219 F40C      BGE	0x021B
    021A C157      RJMP	0x0372
    021B E18A      LDI	R24,0x1A
    021C E090      LDI	R25,0
    021D 2D0A      MOV	R16,R10
    021E 2D1B      MOV	R17,R11
    021F 5F00      SUBI	R16,0xF0
    0220 4010      SBCI	R17,0
    0221 0F00      LSL	R16
    0222 1F11      ROL	R17
    0223 0F08      ADD	R16,R24
    0224 1F19      ADC	R17,R25
    0225 D1A0      RCALL	lpm16
    0226 2FE0      MOV	R30,R16
    0227 2FF1      MOV	R31,R17
    0228 9409      IJMP
(0261) 				{
(0262) 					case SYSEX:
(0263) 						break;
(0264) 					case SYSCOMUNDEF:
(0265) 						break;
(0266) 					case SYSCOMSONGPOS:
(0267) 						break;
(0268) 					case SYSCOMSONGSEL:
(0269) 						break;
(0270) 					case SYSCOMUNDEF1:
(0271) 						break;
(0272) 					case SYSCOMUNDEF2:
(0273) 						break;
(0274) 					case SYSCOMTUNEREQ:
(0275) 						break;
(0276) 					case SYSEXEND:
(0277) 						break;
(0278) 					case SYSRTCLOCK:
(0279) 						Disable();
    0229 DE5E      RCALL	_Disable
(0280) 						GateShadow ^= MIDI_CLOCK;	/*	toggle these bits	*/
    022A E880      LDI	R24,0x80
    022B E090      LDI	R25,0
    022C 902000B2  LDS	R2,_GateShadow
    022E 2433      CLR	R3
    022F 2628      EOR	R2,R24
    0230 2639      EOR	R3,R25
    0231 922000B2  STS	_GateShadow,R2
(0281) 						GATE_PORT = GateShadow;
    0233 9220C000  STS	0xC000,R2
(0282) 						LED_PORT = ~GateShadow;
    0235 9420      COM	R2
    0236 9220C400  STS	0xC400,R2
(0283) 						Enable();
    0238 DE51      RCALL	_Enable
(0284) 						break;
    0239 C138      RJMP	0x0372
(0285) 					case SYSRTUNDEF:
(0286) 						break;
(0287) 					case SYSRTSTART:
(0288) 						Disable();
    023A DE4D      RCALL	_Disable
(0289) 						GateShadow |= MIDI_START;
    023B 918000B2  LDS	R24,_GateShadow
    023D 6480      ORI	R24,0x40
    023E 938000B2  STS	_GateShadow,R24
(0290) 						GateShadow &= ~MIDI_RESET;
    0240 7D8F      ANDI	R24,0xDF
    0241 938000B2  STS	_GateShadow,R24
(0291) 						GATE_PORT = GateShadow;
    0243 2E28      MOV	R2,R24
    0244 9220C000  STS	0xC000,R2
(0292) 						LED_PORT = ~GateShadow;
    0246 9420      COM	R2
    0247 9220C400  STS	0xC400,R2
(0293) 						Enable();				
    0249 DE40      RCALL	_Enable
(0294) 						break;
    024A C127      RJMP	0x0372
(0295) 					case SYSRTCONTINUE:
(0296) 						break;
(0297) 					case SYSRTSTOP:
(0298) 						Disable();
    024B DE3C      RCALL	_Disable
(0299) 						GateShadow &= ~MIDI_START;
    024C 918000B2  LDS	R24,_GateShadow
    024E 7B8F      ANDI	R24,0xBF
    024F 938000B2  STS	_GateShadow,R24
(0300) 						GATE_PORT = GateShadow;
    0251 2E28      MOV	R2,R24
    0252 9220C000  STS	0xC000,R2
(0301) 						LED_PORT = ~GateShadow;
    0254 9420      COM	R2
    0255 9220C400  STS	0xC400,R2
(0302) 						Enable();		
    0257 DE32      RCALL	_Enable
(0303) 						break;
    0258 C119      RJMP	0x0372
(0304) 					case SYSRTUNDEF1:
(0305) 						break;
(0306) 					case SYSRTACTIVESEN:
(0307) 						break;
(0308) 					case SYSRTRESET:
(0309) 						Disable();
    0259 DE2E      RCALL	_Disable
(0310) 						GateShadow &= ~MIDI_START;
    025A 918000B2  LDS	R24,_GateShadow
    025C 7B8F      ANDI	R24,0xBF
    025D 938000B2  STS	_GateShadow,R24
(0311) 						GateShadow |= MIDI_RESET;
    025F 6280      ORI	R24,0x20
    0260 938000B2  STS	_GateShadow,R24
(0312) 						GATE_PORT = GateShadow;
    0262 2E28      MOV	R2,R24
    0263 9220C000  STS	0xC000,R2
(0313) 						LED_PORT = ~GateShadow;
    0265 9420      COM	R2
    0266 9220C400  STS	0xC400,R2
(0314) 						Enable();		
    0268 DE21      RCALL	_Enable
(0315) 						break;
(0316) 				}	//end of swtich(c)
(0317) 			}	//end of if(c < 0xf0)
(0318) 
(0319) 		}
    0269 C108      RJMP	0x0372
(0320) 		else	// if(c & 0x080)
(0321) 		{
(0322) 			switch(cmd)
    026A 8569      LDD	R22,Y+9
    026B 2777      CLR	R23
    026C 3B60      CPI	R22,0xB0
    026D E0E0      LDI	R30,0
    026E 077E      CPC	R23,R30
    026F F409      BNE	0x0271
    0270 C101      RJMP	0x0372
    0271 EB80      LDI	R24,0xB0
    0272 E090      LDI	R25,0
    0273 1786      CP	R24,R22
    0274 0797      CPC	R25,R23
    0275 F0AC      BLT	0x028B
    0276 3960      CPI	R22,0x90
    0277 E0E0      LDI	R30,0
    0278 077E      CPC	R23,R30
    0279 F409      BNE	0x027B
    027A C051      RJMP	0x02CC
    027B E980      LDI	R24,0x90
    027C E090      LDI	R25,0
    027D 1786      CP	R24,R22
    027E 0797      CPC	R25,R23
    027F F02C      BLT	0x0285
    0280 3860      CPI	R22,0x80
    0281 E0E0      LDI	R30,0
    0282 077E      CPC	R23,R30
    0283 F0E9      BEQ	0x02A1
    0284 C0ED      RJMP	0x0372
    0285 3A60      CPI	R22,0xA0
    0286 E0E0      LDI	R30,0
    0287 077E      CPC	R23,R30
    0288 F409      BNE	0x028A
    0289 C091      RJMP	0x031B
    028A C0E7      RJMP	0x0372
    028B 3D60      CPI	R22,0xD0
    028C E0E0      LDI	R30,0
    028D 077E      CPC	R23,R30
    028E F409      BNE	0x0290
    028F C0A1      RJMP	0x0331
    0290 ED80      LDI	R24,0xD0
    0291 E090      LDI	R25,0
    0292 1786      CP	R24,R22
    0293 0797      CPC	R25,R23
    0294 F034      BLT	0x029B
    0295 3C60      CPI	R22,0xC0
    0296 E0E0      LDI	R30,0
    0297 077E      CPC	R23,R30
    0298 F409      BNE	0x029A
    0299 C0D5      RJMP	0x036F
    029A C0D7      RJMP	0x0372
    029B 3E60      CPI	R22,0xE0
    029C E0E0      LDI	R30,0
    029D 077E      CPC	R23,R30
    029E F409      BNE	0x02A0
    029F C0A7      RJMP	0x0347
    02A0 C0D1      RJMP	0x0372
(0323) 			{
(0324) 				case NOTEOFF:
(0325) 					switch(state)
    02A1 854A      LDD	R20,Y+10
    02A2 2755      CLR	R21
    02A3 3041      CPI	R20,1
    02A4 E0E0      LDI	R30,0
    02A5 075E      CPC	R21,R30
    02A6 F029      BEQ	0x02AC
    02A7 3042      CPI	R20,2
    02A8 E0E0      LDI	R30,0
    02A9 075E      CPC	R21,R30
    02AA F059      BEQ	0x02B6
    02AB C0C6      RJMP	0x0372
(0326) 					{
(0327) 						case NOTE0:
(0328) 							nextnote = (int)c << 5;
    02AC E025      LDI	R18,5
    02AD E030      LDI	R19,0
    02AE 8508      LDD	R16,Y+8
    02AF 2711      CLR	R17
    02B0 D151      RCALL	lsl16
    02B1 871D      STD	Y+13,R17
    02B2 870C      STD	Y+12,R16
(0329) 							state = NOTE1;
    02B3 E082      LDI	R24,2
    02B4 878A      STD	Y+10,R24
(0330) 							break;
    02B5 C0BC      RJMP	0x0372
(0331) 						case NOTE1:
(0332) 							if(nextnote == currentnote)
    02B6 840C      LDD	R0,Y+12
    02B7 841D      LDD	R1,Y+13
    02B8 140C      CP	R0,R12
    02B9 041D      CPC	R1,R13
    02BA F469      BNE	0x02C8
(0333) 							{
(0334) 								Disable();
    02BB DDCC      RCALL	_Disable
(0335) 								GateShadow &= ~MIDI_GATE;
    02BC 918000B2  LDS	R24,_GateShadow
    02BE 7F8E      ANDI	R24,0xFE
    02BF 938000B2  STS	_GateShadow,R24
(0336) 								GATE_PORT = GateShadow;
    02C1 2E28      MOV	R2,R24
    02C2 9220C000  STS	0xC000,R2
(0337) 								LED_PORT = ~GateShadow;
    02C4 9420      COM	R2
    02C5 9220C400  STS	0xC400,R2
(0338) 								Enable();
    02C7 DDC2      RCALL	_Enable
(0339) 							}
(0340) 							state = NOTE0;
    02C8 2400      CLR	R0
    02C9 9403      INC	R0
    02CA 860A      STD	Y+10,R0
(0341) 							break;
(0342) 					}
(0343) 					break;
    02CB C0A6      RJMP	0x0372
(0344) 				case NOTEON:
(0345) 					switch(state)
    02CC 842A      LDD	R2,Y+10
    02CD 2433      CLR	R3
    02CE 8239      STD	Y+1,R3
    02CF 8228      STD	Y+0,R2
    02D0 2D82      MOV	R24,R2
    02D1 2D93      MOV	R25,R3
    02D2 3081      CPI	R24,1
    02D3 E0E0      LDI	R30,0
    02D4 079E      CPC	R25,R30
    02D5 F029      BEQ	0x02DB
    02D6 3082      CPI	R24,2
    02D7 E0E0      LDI	R30,0
    02D8 079E      CPC	R25,R30
    02D9 F059      BEQ	0x02E5
    02DA C097      RJMP	0x0372
(0346) 					{
(0347) 						case NOTE0:
(0348) 							nextnote = (int)c << 5;
    02DB E025      LDI	R18,5
    02DC E030      LDI	R19,0
    02DD 8508      LDD	R16,Y+8
    02DE 2711      CLR	R17
    02DF D122      RCALL	lsl16
    02E0 871D      STD	Y+13,R17
    02E1 870C      STD	Y+12,R16
(0349) 							state = NOTE1;
    02E2 E082      LDI	R24,2
    02E3 878A      STD	Y+10,R24
(0350) 							break;
    02E4 C08D      RJMP	0x0372
(0351) 						case NOTE1:
(0352) 							Disable();
    02E5 DDA2      RCALL	_Disable
(0353) 							if(c > 0)
    02E6 2422      CLR	R2
    02E7 8408      LDD	R0,Y+8
    02E8 1420      CP	R2,R0
    02E9 F4D8      BCC	0x0305
(0354) 							{
(0355) 								currentnote = nextnote;
    02EA 84CC      LDD	R12,Y+12
    02EB 84DD      LDD	R13,Y+13
(0356) 								SendData(currentnote,0);
    02EC 2722      CLR	R18
    02ED 2733      CLR	R19
    02EE 2D0C      MOV	R16,R12
    02EF 2D1D      MOV	R17,R13
    02F0 D095      RCALL	_SendData
(0357) 								if(GateShadow & MIDI_GATE)	//is gate already set?
    02F1 902000B2  LDS	R2,_GateShadow
    02F3 FE20      SBRS	R2,0
    02F4 C00A      RJMP	0x02FF
(0358) 								{
(0359) 									GateShadow &= ~MIDI_GATE;	//retrigger gate
    02F5 2D82      MOV	R24,R2
    02F6 7F8E      ANDI	R24,0xFE
    02F7 938000B2  STS	_GateShadow,R24
(0360) 									GATE_PORT = GateShadow;
    02F9 2E28      MOV	R2,R24
    02FA 9220C000  STS	0xC000,R2
(0361) 									LED_PORT = ~GateShadow;
    02FC 9420      COM	R2
    02FD 9220C400  STS	0xC400,R2
(0362) 								}
(0363) 								GateShadow |= MIDI_GATE;
    02FF 918000B2  LDS	R24,_GateShadow
    0301 6081      ORI	R24,1
    0302 938000B2  STS	_GateShadow,R24
(0364) 							}
    0304 C00A      RJMP	0x030F
(0365) 							else
(0366) 							{
(0367) 								if(currentnote == nextnote)
    0305 840C      LDD	R0,Y+12
    0306 841D      LDD	R1,Y+13
    0307 14C0      CP	R12,R0
    0308 04D1      CPC	R13,R1
    0309 F429      BNE	0x030F
(0368) 								{
(0369) 									GateShadow &= ~MIDI_GATE;
    030A 918000B2  LDS	R24,_GateShadow
    030C 7F8E      ANDI	R24,0xFE
    030D 938000B2  STS	_GateShadow,R24
(0370) 								}
(0371) 							}
(0372) 							GATE_PORT = GateShadow;
    030F 902000B2  LDS	R2,_GateShadow
    0311 9220C000  STS	0xC000,R2
(0373) 							LED_PORT = ~GateShadow;
    0313 9420      COM	R2
    0314 9220C400  STS	0xC400,R2
(0374) 							Enable();
    0316 DD73      RCALL	_Enable
(0375) 							state = NOTE0;
    0317 2400      CLR	R0
    0318 9403      INC	R0
    0319 860A      STD	Y+10,R0
(0376) 							break;
(0377) 						default:
(0378) 							break;
(0379) 					}
(0380) 					break;
    031A C057      RJMP	0x0372
(0381) 				case NOTEPRES:	//note pressure
(0382) 					switch(state)
    031B 842A      LDD	R2,Y+10
    031C 2433      CLR	R3
    031D 823B      STD	Y+3,R3
    031E 822A      STD	Y+2,R2
    031F 2D82      MOV	R24,R2
    0320 2D93      MOV	R25,R3
    0321 3081      CPI	R24,1
    0322 E0E0      LDI	R30,0
    0323 079E      CPC	R25,R30
    0324 F029      BEQ	0x032A
    0325 3082      CPI	R24,2
    0326 E0E0      LDI	R30,0
    0327 079E      CPC	R25,R30
    0328 F021      BEQ	0x032D
    0329 C048      RJMP	0x0372
(0383) 					{
(0384) 						case NOTE0:
(0385) 							state = NOTE1;
    032A E082      LDI	R24,2
    032B 878A      STD	Y+10,R24
(0386) 							break;
    032C C045      RJMP	0x0372
(0387) 						case NOTE1:
(0388) 							state = NOTE0;
    032D 2400      CLR	R0
    032E 9403      INC	R0
    032F 860A      STD	Y+10,R0
(0389) 							break;
(0390) 					}
(0391) 					break;
    0330 C041      RJMP	0x0372
(0392) 				case CHANPRES:		//channel pressure
(0393) 					break;
(0394) 				case CONTROL:			//control change
(0395) 					switch(state)
    0331 842A      LDD	R2,Y+10
    0332 2433      CLR	R3
    0333 823D      STD	Y+5,R3
    0334 822C      STD	Y+4,R2
    0335 2D82      MOV	R24,R2
    0336 2D93      MOV	R25,R3
    0337 3081      CPI	R24,1
    0338 E0E0      LDI	R30,0
    0339 079E      CPC	R25,R30
    033A F029      BEQ	0x0340
    033B 3082      CPI	R24,2
    033C E0E0      LDI	R30,0
    033D 079E      CPC	R25,R30
    033E F021      BEQ	0x0343
    033F C032      RJMP	0x0372
(0396) 					{
(0397) 						case NOTE0:
(0398) 							state = NOTE1;
    0340 E082      LDI	R24,2
    0341 878A      STD	Y+10,R24
(0399) 							break;
    0342 C02F      RJMP	0x0372
(0400) 						case NOTE1:
(0401) 							state = NOTE0;
    0343 2400      CLR	R0
    0344 9403      INC	R0
    0345 860A      STD	Y+10,R0
(0402) 							break;
(0403) 					}
(0404) 					break;
    0346 C02B      RJMP	0x0372
(0405) 				case WHEEL:			//pitch wheel change
(0406) 					switch(state)
    0347 842A      LDD	R2,Y+10
    0348 2433      CLR	R3
    0349 823F      STD	Y+7,R3
    034A 822E      STD	Y+6,R2
    034B 2D82      MOV	R24,R2
    034C 2D93      MOV	R25,R3
    034D 3081      CPI	R24,1
    034E E0E0      LDI	R30,0
    034F 079E      CPC	R25,R30
    0350 F029      BEQ	0x0356
    0351 3082      CPI	R24,2
    0352 E0E0      LDI	R30,0
    0353 079E      CPC	R25,R30
    0354 F031      BEQ	0x035B
    0355 C01C      RJMP	0x0372
(0407) 					{
(0408) 						case NOTE0:
(0409) 							v = ((int)c);
    0356 84E8      LDD	R14,Y+8
    0357 24FF      CLR	R15
(0410) 							state = NOTE1;
    0358 E082      LDI	R24,2
    0359 878A      STD	Y+10,R24
(0411) 							break;
    035A C017      RJMP	0x0372
(0412) 						case NOTE1:
(0413) 							v |= ((int)c)<<7;
    035B E027      LDI	R18,7
    035C E030      LDI	R19,0
    035D 8508      LDD	R16,Y+8
    035E 2711      CLR	R17
    035F D0A2      RCALL	lsl16
    0360 2AE0      OR	R14,R16
    0361 2AF1      OR	R15,R17
(0414) 							v >>= 2;	//12 bits;
    0362 94F5      ASR	R15
    0363 94E7      ROR	R14
    0364 94F5      ASR	R15
    0365 94E7      ROR	R14
(0415) 			//				v ^= 0x0800;
(0416) 							SendData(v,1);
    0366 E021      LDI	R18,1
    0367 E030      LDI	R19,0
    0368 2D0E      MOV	R16,R14
    0369 2D1F      MOV	R17,R15
    036A D01B      RCALL	_SendData
(0417) 							state = NOTE0;
    036B 2400      CLR	R0
    036C 9403      INC	R0
    036D 860A      STD	Y+10,R0
(0418) 							break;
(0419) 					}
(0420) 					break;
    036E C003      RJMP	0x0372
(0421) 				case PATCH:			//patch change
(0422) 					state = NOTE0;
    036F 2400      CLR	R0
    0370 9403      INC	R0
    0371 860A      STD	Y+10,R0
    0372 CE81      RJMP	0x01F4
(0423) 					break;
(0424) 			}	//end of switch(cmd)
(0425) 		}	//end of if(c & 0x080)
(0426) 
(0427) 	}	//end of while(1) loop
(0428) 	return 0;
    0373 2700      CLR	R16
    0374 2711      CLR	R17
    0375 962E      ADIW	R28,0xE
    0376 9508      RET
FILE: C:\projects\SynthMod\100-1001\firmware\spi.c
(0001) /******************************************************************************
(0002) **
(0003) ** These are the routines for talking to the SPI port
(0004) **
(0005) ** The SPI port will output a 16 bit integer to the DAC
(0006) **  It will then latch the data into the appropriate DAC register
(0007) **
(0008) *******************************************************************************/
(0009) #include <io8515v.h>
(0010) #include <macros.h>
(0011) #include "smb.h"
(0012) 
(0013) /*******************************************************************************
(0014) **
(0015) ** This routine initializes the SPI port and gets it ready for use
(0016) **
(0017) *******************************************************************************/
(0018) void InitSPI(void)
(0019) {
(0020) 	DDRB |= 0xb0;	/*	set SS pin to output	*/
_InitSPI:
    0377 B387      IN	R24,0x17
    0378 6B80      ORI	R24,0xB0
    0379 BB87      OUT	0x17,R24
(0021) 	SPCR = SPI_SPCR_SPE | SPI_SPCR_CPHA | SPI_SPCR_MSTR;	/*	enable SPI port	*/	
    037A E584      LDI	R24,0x54
    037B B98D      OUT	0x0D,R24
(0022) 	MCUCR |= 0x80;	/*	enable external memory	*/
    037C B785      IN	R24,0x35
    037D 6880      ORI	R24,0x80
    037E BF85      OUT	0x35,R24
(0023) }
    037F 9508      RET
(0024) 
(0025) /*******************************************************************************
(0026) ** Wait for data to exit from SPI port
(0027) ** Returns true while data is still transmiting
(0028) *******************************************************************************/
(0029) 
(0030) int PortFull(void)
(0031) {
(0032) 	char a;
(0033) 	int retval=0;
_PortFull:
  a                    --> R18
  retval               --> R16
    0380 2700      CLR	R16
    0381 2711      CLR	R17
(0034) 	a = SPSR;
    0382 B12E      IN	R18,0x0E
(0035) 	if(a & 0x80) retval = 1;
    0383 FD27      SBRC	R18,7
    0384 E001      LDI	R16,1
(0036) 	return retval;
    0385 9508      RET
_SendData:
  convert              --> Y+0
  port                 --> R20
  d                    --> R22
    0386 D03C      RCALL	push_gset2
    0387 2F42      MOV	R20,R18
    0388 2F53      MOV	R21,R19
    0389 2F60      MOV	R22,R16
    038A 2F71      MOV	R23,R17
    038B 9722      SBIW	R28,2
(0037) }
(0038) 
(0039) /*******************************************************************************
(0040) This routine sends data d to DAC port port
(0041) *******************************************************************************/
(0042) static const int DacLUT[8] = {
(0043) 	0xa000,
(0044) 	0xa400,
(0045) 	0xa800,
(0046) 	0xac00,
(0047) 	0xb000,
(0048) 	0xb400,
(0049) 	0xb800,
(0050) 	0xbc00
(0051) };
(0052) 
(0053) 
(0054) void SendData(int d,int port)
(0055) {
(0056) 	union {
(0057) 		int v;
(0058) 		char b[2];
(0059) 	}convert;
(0060) 	convert.v = d;
    038C 8379      STD	Y+1,R23
    038D 8368      STD	Y+0,R22
(0061) 	SPDR = convert.b[1];	/*	get MSB of data	*/
    038E 8029      LDD	R2,Y+1
    038F B82F      OUT	0x0F,R2
(0062) 	while(!PortFull());			/*	wait for data to be transmitted	*/
    0390 DFEF      RCALL	_PortFull
    0391 3000      CPI	R16,0
    0392 0701      CPC	R16,R17
    0393 F3E1      BEQ	0x0390
(0063) 	SPDR = convert.b[0];			/*	get LSB of data	*/
    0394 8028      LDD	R2,Y+0
    0395 B82F      OUT	0x0F,R2
(0064) 	while(!PortFull());		/*	wait for data to be transmitted	*/
    0396 DFE9      RCALL	_PortFull
    0397 3000      CPI	R16,0
    0398 0701      CPC	R16,R17
    0399 F3E1      BEQ	0x0396
(0065) 	*((volatile char *)DacLUT[port]) = 0;	//dummy write to load DAC	*/	
    039A E38A      LDI	R24,0x3A
    039B E090      LDI	R25,0
    039C 2F04      MOV	R16,R20
    039D 2F15      MOV	R17,R21
    039E 0F00      LSL	R16
    039F 1F11      ROL	R17
    03A0 0F08      ADD	R16,R24
    03A1 1F19      ADC	R17,R25
    03A2 D023      RCALL	lpm16
    03A3 2FE0      MOV	R30,R16
    03A4 2FF1      MOV	R31,R17
    03A5 2422      CLR	R2
    03A6 8220      STD	Z+0,R2
(0066) }
FILE: <library>
    03A7 9622      ADIW	R28,2
    03A8 D001      RCALL	pop_gset2
    03A9 9508      RET
pop_gset2:
    03AA E0E2      LDI	R30,2
    03AB C004      RJMP	pop
push_gset1:
    03AC 935A      ST	R21,-Y
    03AD 934A      ST	R20,-Y
    03AE 9508      RET
pop_gset1:
    03AF E0E1      LDI	R30,1
pop:
    03B0 9149      LD	R20,Y+
    03B1 9159      LD	R21,Y+
    03B2 FDE0      SBRC	R30,0
    03B3 9508      RET
    03B4 9169      LD	R22,Y+
    03B5 9179      LD	R23,Y+
    03B6 FDE1      SBRC	R30,1
    03B7 9508      RET
    03B8 90A9      LD	R10,Y+
    03B9 90B9      LD	R11,Y+
    03BA FDE2      SBRC	R30,2
    03BB 9508      RET
    03BC 90C9      LD	R12,Y+
    03BD 90D9      LD	R13,Y+
    03BE FDE3      SBRC	R30,3
    03BF 9508      RET
    03C0 90E9      LD	R14,Y+
    03C1 90F9      LD	R15,Y+
    03C2 9508      RET
push_gset2:
    03C3 937A      ST	R23,-Y
    03C4 936A      ST	R22,-Y
    03C5 CFE6      RJMP	push_gset1
lpm16:
    03C6 93EA      ST	R30,-Y
    03C7 93FA      ST	R31,-Y
    03C8 920A      ST	R0,-Y
    03C9 2FE0      MOV	R30,R16
    03CA 2FF1      MOV	R31,R17
    03CB 95C8      LPM
    03CC 2D00      MOV	R16,R0
    03CD 9631      ADIW	R30,1
    03CE 95C8      LPM
    03CF 2D10      MOV	R17,R0
    03D0 9009      LD	R0,Y+
    03D1 91F9      LD	R31,Y+
    03D2 91E9      LD	R30,Y+
    03D3 9508      RET
push_lset:
    03D4 93FA      ST	R31,-Y
    03D5 93EA      ST	R30,-Y
    03D6 93BA      ST	R27,-Y
    03D7 93AA      ST	R26,-Y
    03D8 939A      ST	R25,-Y
    03D9 938A      ST	R24,-Y
    03DA 933A      ST	R19,-Y
    03DB 932A      ST	R18,-Y
    03DC 931A      ST	R17,-Y
    03DD 930A      ST	R16,-Y
    03DE 929A      ST	R9,-Y
    03DF 928A      ST	R8,-Y
    03E0 927A      ST	R7,-Y
    03E1 926A      ST	R6,-Y
    03E2 925A      ST	R5,-Y
    03E3 924A      ST	R4,-Y
    03E4 923A      ST	R3,-Y
    03E5 922A      ST	R2,-Y
    03E6 921A      ST	R1,-Y
    03E7 920A      ST	R0,-Y
    03E8 B60F      IN	R0,0x3F
    03E9 920A      ST	R0,-Y
    03EA 9508      RET
pop_lset:
    03EB 9009      LD	R0,Y+
    03EC BE0F      OUT	0x3F,R0
    03ED 9009      LD	R0,Y+
    03EE 9019      LD	R1,Y+
    03EF 9029      LD	R2,Y+
    03F0 9039      LD	R3,Y+
    03F1 9049      LD	R4,Y+
    03F2 9059      LD	R5,Y+
    03F3 9069      LD	R6,Y+
    03F4 9079      LD	R7,Y+
    03F5 9089      LD	R8,Y+
    03F6 9099      LD	R9,Y+
    03F7 9109      LD	R16,Y+
    03F8 9119      LD	R17,Y+
    03F9 9129      LD	R18,Y+
    03FA 9139      LD	R19,Y+
    03FB 9189      LD	R24,Y+
    03FC 9199      LD	R25,Y+
    03FD 91A9      LD	R26,Y+
    03FE 91B9      LD	R27,Y+
    03FF 91E9      LD	R30,Y+
    0400 91F9      LD	R31,Y+
    0401 9508      RET
lsl16:
    0402 2322      TST	R18
    0403 F021      BEQ	0x0408
    0404 0F00      LSL	R16
    0405 1F11      ROL	R17
    0406 952A      DEC	R18
    0407 CFFA      RJMP	lsl16
    0408 9508      RET
